---
title: 排序算法
date: 2018-05-01 16:37:37
tags:
    - Java
    - 数据结构与算法
    
---

快速排序
-----------
最经典实现，worst case为$O(n^2)$。但随机化后最坏情况也能达到$O(n\log(n))$。
在这里提一下二叉搜索树（BST），它与快速排序有着民曲同工之妙。
比如：对6，10，13，5，8，3，2进行排序
快排，以6为key，小于6的放到左边，其他放到右边


|6 |10|13|5 |8 |3 |2 |
|:-|:-|:-|:-|:-|:-|:-|
|$i,j$| | | | | | |
|6 |<font color="red">10</font>|13|<font color="red">5</font>|8|3|2|
||$i$| |$j$| | | |
|6|5|<font color="red">13</font>|10|8|<font color="red">3</font>|2|
| | |$i$| | |$j$| |
|6|5|3|<font color="red">10</font>|8|13|<font color="red">2</font>|
| | | |$i$| | |$j$|
|<font color="red">6</font>|5|3|<font color="red">2</font>|8|13|10|
|$\uparrow$| | |$\uparrow$| | | |
|2|5|3|6|8|13|10|

BST版本：比6小的都放到了左子树，其他的都放到了右子树。

``` java
            6
          /   \
         5     8
        /       \
       3         13
      /          /
     2          10
```

### 快排的代码实现
``` java
package Algorithm;

import java.util.Arrays;

public class QuickSort {

    public static void main(String[] args) {
        QuickSort qs = new QuickSort();
        int[] array = new int[]{3, 8, 4, 2, 6, 11, 13, 6};
        System.out.printf("before: %s\n", Arrays.toString(array));
        qs.quicksort(array);
        System.out.printf("after: %s\n", Arrays.toString(array));
    }

    public void quicksort(int[] array) {
        quicksort(array, 0, array.length);
    }

    private void quicksort(int[] array, int from, int to) {
        if (from >= to - 1) {
            return;
        }

        int key = array[from];
        int i, j;
        for (i = from, j = from + 1; j < to; j++) {
            if (array[j] < key) {
                swap(array, ++i, j);
            }
        }
        swap(array, from, i);
        quicksort(array, from, i);
        quicksort(array, i + 1, to);
    }

    private void swap(int[] array, int i, int j) {
        int tmp = array[i];
        array[i] = array[j];
        array[j] = tmp;
    }
    
} /*
输出结果
before: [3, 8, 4, 2, 6, 11, 13, 6]
after: [2, 3, 4, 6, 6, 8, 11, 13]
*/
```


堆排序(heapsort)
-----------------------
调整根结点为最大值（最大堆），然后把根结点的值与数组最后的值交换，并在逻辑上将数组的长度减一，重构最大堆，如此循环往复，直到遍历完最后一个元素。
### 代码实现

``` java
package Algorithm;

import java.util.Arrays;

public class HeapSort {

    public static void main(String[] args) {
        HeapSort heapSort = new HeapSort();
        int[] test = new int[]{7, 8, 5, 9, 3, 2, 6};
        System.out.printf("before: %s\n",Arrays.toString(test));
        System.out.printf("after: %s\n",Arrays.toString(heapSort.heapsort(test)));    }
    
    public void adjust(int[] left, int i, int len) {

        int lChild = 2 * i + 1;
        int rChild = 2 * i + 2;
        int max = i;

        if (i < len) {
           if (lChild < len && left[lChild] > left[max])
               max = lChild;
           if (rChild < len && left[rChild] > left[max])
               max = rChild;
           if (i != max) {
               swap(left, i, max);
               adjust(left, max, len);
           }
        }
    }

    public int[] heapsort(int[] unsorted) {

        for (int i = (unsorted.length) / 2 - 1; i >= 0; i--) {
            adjust(unsorted, i, unsorted.length - 1);
        }

        for (int i = unsorted.length - 1; i > 0; i--) {
            swap(unsorted, 0, i);
            adjust(unsorted, 0, i);
        }

        return unsorted;
    }
    public void swap(int[] target, int i, int j) {
        int tmp = target[i];
        target[i] = target[j];
        target[j] = tmp;
    }
}/*
输出结果
before: [7, 8, 5, 9, 3, 2, 6]
after: [2, 3, 5, 6, 7, 8, 9]
*/
```


其他排序待补充
---------------------

